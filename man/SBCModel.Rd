% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sample.R
\name{SBCModel}
\alias{SBCModel}
\title{R6 Class Representing a collection of functions to extract data from a single model}
\description{
R6 Class Representing a collection of functions to extract data from a single model

R6 Class Representing a collection of functions to extract data from a single model
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{name}}{Some string to identify your SBCModel}

\item{\code{stan_model}}{A CmdStanModel or a stanmodel}

\item{\code{model_type}}{A string containing self$stan_model type. can be either RSTAN_MODEL_CLASS_NAME or CMDSTAN_MODEL_CLASS_NAME}

\item{\code{parameter_dims}}{A list containing dimension info for parameters
Initialize a SBCModel with a existing stan Model}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{SBCModel$new()}}
\item \href{#method-sample_theta_tilde}{\code{SBCModel$sample_theta_tilde()}}
\item \href{#method-sample_theta_tilde_stan}{\code{SBCModel$sample_theta_tilde_stan()}}
\item \href{#method-sample_y_tilde}{\code{SBCModel$sample_y_tilde()}}
\item \href{#method-sample_theta_bar_y}{\code{SBCModel$sample_theta_bar_y()}}
\item \href{#method-sample_bootstrap_y_tilde}{\code{SBCModel$sample_bootstrap_y_tilde()}}
\item \href{#method-sample_all}{\code{SBCModel$sample_all()}}
\item \href{#method-infer_sequential_params}{\code{SBCModel$infer_sequential_params()}}
\item \href{#method-par_list_to_structure}{\code{SBCModel$par_list_to_structure()}}
\item \href{#method-clone}{\code{SBCModel$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SBCModel$new(name, stan_model = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{Some string to identify your SBCModel}

\item{\code{stan_model}}{A 'CmdStanModel' or a 'stanmodel' to draw samples}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-sample_theta_tilde"></a>}}
\if{latex}{\out{\hypertarget{method-sample_theta_tilde}{}}}
\subsection{Method \code{sample_theta_tilde()}}{
Sample \eqn{\tilde{\theta} ~ P(\theta)} (Prior predictive sampling)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SBCModel$sample_theta_tilde(pars, n_iters, hyperpriors = list())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pars}}{List of parameters to draw prior samples.}

\item{\code{n_iters}}{Integer specifying number of draws.}

\item{\code{hyperpriors}}{A named list containing prior definitions and sampling functions. Follows the format:
list(param1=func, param2=func) where func is a function that returns a single value for each parameter}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
List of length(pars) where each element is an array of dimension(n_iters, length(par[i])) containing sampled prior values.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-sample_theta_tilde_stan"></a>}}
\if{latex}{\out{\hypertarget{method-sample_theta_tilde_stan}{}}}
\subsection{Method \code{sample_theta_tilde_stan()}}{
Try and use the stan code to sample theta values(prior predictive sampling).
This is useful if you have prior simulation defined in generated quantities.
Note that this does \emph{not} use the model, since Stan doesn't directly sample from the prior.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SBCModel$sample_theta_tilde_stan(
  pars_list,
  n_iters,
  data = list(),
  suffix = "_"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pars_list}}{list of parameter names to draw}

\item{\code{n_iters}}{integer specifying number of individual draws}

\item{\code{data}}{additional data for the model, if necessary}

\item{\code{suffix}}{additional suffix added to simulated parameter names. default is "\emph{". For example,
if the parameter is called "mu", "mu}" will be sampled as the prior predictive distribution.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
List of length(pars) where each element is an array of dimension(n_iters, length(par[i])) containing sampled prior values.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-sample_y_tilde"></a>}}
\if{latex}{\out{\hypertarget{method-sample_y_tilde}{}}}
\subsection{Method \code{sample_y_tilde()}}{
sample \eqn{\tilde{y} ~ p(\tilde{y} | \tilde{\theta})}, or y_tilde ~ P(y_tilde | theta_tilde),
which is the Posterior Predictive Distribution.
The stan model must specify P(y | theta) within the generated quantities block
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SBCModel$sample_y_tilde(theta_arr, y_var = "y_", data = list())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{theta_arr}}{Array of sampled prior theta values, which is outputted from self$sample_theta_tilde_stan()}

\item{\code{y_var}}{y_tilde variable name. Will be retrieved from model as so: y_[n] (1<=n<=y_count)}

\item{\code{data}}{data list to pass to the stan model, in most cases would be dummy data since data will be drawn with fixed params}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
array of dimension (n_iters, y_dim, ...) of sampled y. Each row is a sample vector for a single parameter vector
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-sample_theta_bar_y"></a>}}
\if{latex}{\out{\hypertarget{method-sample_theta_bar_y}{}}}
\subsection{Method \code{sample_theta_bar_y()}}{
Sample \eqn{\theta ~ p(\theta | \tilde{y})}, to retrieve parameters from samples.
The stan model must have \eqn{\theta} defined as parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SBCModel$sample_theta_bar_y(
  y_sample_arr,
  data = list(),
  pars = list(),
  fit_iter = 200
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{y_sample_arr}}{array of dimension (n_iters, y_dim, ...) of sampled y. Same as output of self$sample_y_tilde()}

\item{\code{data}}{list of additional data to pass to the stan model. Note that "y" will be overwritten with draws from y_sample_arr.}

\item{\code{pars}}{list of parameters of interest.}

\item{\code{fit_iter}}{number of model iterations, which equates to the number of posterior draws per sample set.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
: array of dimension (fit_iter, n_pars, n_iters) of posterior parameter draws
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-sample_bootstrap_y_tilde"></a>}}
\if{latex}{\out{\hypertarget{method-sample_bootstrap_y_tilde}{}}}
\subsection{Method \code{sample_bootstrap_y_tilde()}}{
sample \eqn{\tilde{y}^{*} ~ Bootstrap(\tilde{y})}
given a single vector of data y_tilde, bootstrap sample multiple values of y_tilde_star[i] from bootstrap(y_tilde)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SBCModel$sample_bootstrap_y_tilde(y_sample_vector, n_iters = 2000)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{y_sample_vector}}{vector of y samples.}

\item{\code{n_iters}}{number of bootstrap samples to draw}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
array of dimension (n_iters, y_count) of bootstrap sampled y
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-sample_all"></a>}}
\if{latex}{\out{\hypertarget{method-sample_all}{}}}
\subsection{Method \code{sample_all()}}{
High level function that automatically runs all low level sampling functions, and returns just posterior rank statistics.
Output is same as SBC::calculte_rank()
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SBCModel$sample_all(
  priors = list(),
  pars = list(),
  prior_suffix = "_",
  n_iters = 20,
  n_fits = 200,
  data = list(),
  y_gq_name = "y_",
  thin = 3
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{priors}}{named list of functions which define how each parameter's prior is sampled. If empty, will be
sampled from stan with the assumption that it's defined within generated quantities.}

\item{\code{pars}}{list of base parameter names of interest(no indexes)}

\item{\code{prior_suffix}}{additional suffix added to simulated parameter names. default is "_"}

\item{\code{n_iters}}{number of SBC iterations to run. default is 20}

\item{\code{n_fits}}{number of iterations to fit theta. default is 200}

\item{\code{data}}{list of additional data necessary for the model to run}

\item{\code{y_gq_name}}{name of posterior predictive variable for y. default is "y_"}

\item{\code{thin}}{sample thinning interval. default is 3}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
array of dimension (n_iters, n_pars) of posterior rank statistics
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-infer_sequential_params"></a>}}
\if{latex}{\out{\hypertarget{method-infer_sequential_params}{}}}
\subsection{Method \code{infer_sequential_params()}}{
Given list of base parameter names and stan summary matrix, return list of all individual index parameter names
For example, if the model contained a vector[5] parname as a parameter, you can run infer_sequential_param("parname", ...)
and it will return a list of strings "parname[1]", "parname[2]", ...
This function will also search for multidimensional array types, up to dimension (max_dims).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SBCModel$infer_sequential_params(
  par_names,
  summary_data,
  max_dims = 3,
  return_dim_info = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{par_names}}{list of base parameter names to find indexes}

\item{\code{summary_data}}{stansummary matrix that has row names as indexed parameter names, and at least "mean" in its column. It
must raise a subscript error if a row that doesn't exist is indexed. Same as output of rstan::summary}

\item{\code{max_dims}}{Maximum dimension to search}

\item{\code{return_dim_info}}{Boolean indicating whether to additionally return dimension info. Default is FALSE}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
list of strings, that represent indexed parameter names, or a list containing string and dimensions for each parameter if return_dim_info is TRUE
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-par_list_to_structure"></a>}}
\if{latex}{\out{\hypertarget{method-par_list_to_structure}{}}}
\subsection{Method \code{par_list_to_structure()}}{
Given a named list, where indexes are parameter names with bracketed indexes(in the form of mu[1], mu[2]),
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SBCModel$par_list_to_structure(named_list)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{named_list}}{A named list containing bracketed indexed parameter names as indexes.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with bracketed names removed, and with adequate vector/matrix structures.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{SBCModel$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
